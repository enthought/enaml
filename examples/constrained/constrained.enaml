""" Demo of how the constraint-based layout engine can be used to create fluid,
adaptable layouts.

At the top, we have the "Frame" PushButton that is just a dummy standin for
a larger, expandable widget, like a table. Below the Frame are four PushButtons.
On the left are the Add and Remove buttons, which hug the left and bottom sides
of their container and stay close to each other. Hugging the bottom right corner
is the Share PushButton. Centered is the Change Mode PushButton. However, as the
window gets resized, the Change Mode button may not be able to be centered, but
it will always leave a gap between it and its two neighbors.

Pressing the Change Mode PushButton will increase the amount of text on that
button, thus forcing changes to the layout due to the new size hint for that
PushButton.

Pressing the Share PushButton will add a new constraint that forces the width of
that PushButton to increase to 200.
"""

defn MainWindow:
    Window:
        constraints = [
            # Arrange the vertical layout of frame and buttons in the window
            vertical(top, frame, add_button, bottom),

            # Arrange the horizontal layout of the frame in the window
            horizontal(left, frame, right),

            # Arranges the horizontal layout of buttons in the window
            horizontal(add_button, remove_button, _space_, change_mode_button, _space_, share_button),

            # Align the bottom edge of all buttons
            align('bottom', add_button, remove_button, change_mode_button, share_button),

            # Align the left edge of the first button and the frame
            align('left', frame, add_button),

            # Align the right edge of the last button and the frame
            align('right', frame, share_button),

            # Weakly align the center of the frame and the center button
            align('h_center', frame, change_mode_button) | 'weak',

            # Set a sensible minimum height for the frame
            frame.height >= 150,
        ]
        PushButton -> frame:
            text = 'Frame'
            # Tell the layout manager to ignore hugging constraints
            # for this button so that it expands in both directions.
            # (Setting to 'weak' would also work, but requires more 
            # computation by the solver).
            hug_width = 'ignore'
            hug_height = 'ignore'
        PushButton -> add_button:
            text = 'Add'
            # Uncomment the next four lines to see how to play around with 
            # the hugging and resist_clip properties
            #hug_width = 'weak'
            #hug_height = 'strong'
            #resist_clip_width = 'weak'
            #resist_clip_height = 'strong')
        PushButton -> remove_button:
            text = 'Remove'
        PushButton -> change_mode_button:
            text = 'Change Mode'
            # Click this button to update the button text and have
            # it expand to fit its contents
            clicked >> setattr(self, 'text', text * 2)
        PushButton -> share_button:
            text = 'Share...'
            # Click this button to force it to have a width of 200
            clicked >> parent.constraints.append(width == 200)



#------------------------------------------------------------------------------
#  Copyright (c) 2011, Enthought, Inc.
#  All rights reserved.
#------------------------------------------------------------------------------
""" An amalgamation of utilities used throughout the Enaml framework.

"""
from collections import defaultdict
from functools import wraps
import logging
from random import shuffle
from string import letters, digits
import traceback
from types import MethodType
from weakref import ref


def id_generator(stem):
    """ A unique identifier generator.

    For a given stem, the returned generator is guaranteed to yield
    consecutively increasing identifiers using a randomly ordered
    base 62 charset. The identifiers are only guaranteed unique for a
    given instance of the generator. The randomness is employed to 
    improve the hashing characteristics of the returned identifiers.

    Parameters
    ----------
    stem : str
        A string stem to prepend to a incrementing integer value.

    """
    charset = list(digits + letters)
    shuffle(charset)
    charset = ''.join(charset)
    charsetlen = len(charset)
    places = [0]
    push = places.append
    enumerate_ = enumerate
    join = ''.join
    while True:
        yield stem + join(charset[digit] for digit in places)
        for idx, digit in enumerate_(places):
            digit += 1 
            if digit == charsetlen:
                places[idx] = 0
            else:
                places[idx] = digit
                break 
        if places[-1] == 0:
            push(1)


class abstractclassmethod(classmethod):
    """ A backport of the Python 3's abc.abstractclassmethod.

    """
    __isabstractmethod__ = True

    def __init__(self, func):
        func.__isabstractmethod__ = True
        super(abstractclassmethod, self).__init__(func)


class WeakMethod(object):
    """ An object which weakly binds a method with a lifetime bound
    to the lifetime of the underlying object. 

    Instances of WeakMethod are also weakref-able with a lifetime which 
    is also bound to lifetime of the method owner.

    If multiple WeakMethods are requested for the same equivalent method
    object, the same WeakMethod will be returned. This behavior is the
    same as the standard weakref semantics.

    """
    __slots__ = ('_key', '__weakref__')

    #: An internal dict which maintains a strong reference to the
    #: the underlying weak method wrappers until the owner of the 
    #: method is destroyed.
    _instances = defaultdict(list)

    def __new__(cls, method):
        """ Create a new WeakMethod instance or return an equivalent 
        which already exists.

        Parameters
        ----------
        method : A bound method object
            The bound method which should be wrapped weakly.

        """
        def remove(wr_item):
            WeakMethod._instances.pop(wr_item, None)
        sref = ref(method.im_self, remove)
        key = (method.im_func, sref, method.im_class)
        if sref in WeakMethod._instances:
            for item in WeakMethod._instances[sref]:
                if item._key == key:
                    return item
        self = super(WeakMethod, cls).__new__(cls)
        self._key = key
        WeakMethod._instances[sref].append(self)
        return self

    def __call__(self, *args, **kwargs):
        """ Invoke the wrapped method by reconstructing the bound
        method from its components.

        If the underlying instance object has been destroyed, this
        method will return the default value.

        Parameters
        ----------
        args
            The positional arguments to pass to the method.

        kwargs
            The keyword arguments to pass to the method.

        """
        im_func, im_self_ref, im_class = self._key
        im_self = im_self_ref()
        if im_self is None:
            return
        method = MethodType(im_func, im_self, im_class)
        return method(*args, **kwargs)


class LoopbackContext(object):
    """ A context manager generated by a LoopbackGuard which manages
    acquiring and releasing the lock items.

    """
    def __init__(self, guard, lock_items):
        """ Initialize a LoopbackContext

        Parameters
        ----------
        guard : LoopbackGuard
            The loopback guard instance for which we will acquire the
            lock for the items.

        lock_items : iterable
            An iterable items which will be passed to the 'acquire'
            method on the loopback guard.

        """
        self._guard = guard
        self._lock_items = lock_items

    def __enter__(self):
        """ Acquire the guard lock on the lock items.

        """
        self._guard.acquire(self._lock_items)

    def __exit__(self, exc_type, exc_value, traceback):
        """ Release the guard lock on the lock items.

        """
        self._guard.release(self._lock_items)


class LoopbackGuard(object):
    """ A guard object used by objects to protect against loopback 
    conditions while updating attributes on the component.

    Instances of this class are callable and return a guarding 
    context manager for the provided lock items.

    """
    def __init__(self):
        """ Initialize a LoopbackGuard.

        """
        self._locked = defaultdict(int)

    def __call__(self, *items):
        """ Return a context manager which will guard the given items.

        Parameters
        ----------
        items
            The items for which to acquire the guard from within the
            returned context manager. These items must be hashable.

        Returns
        -------
        result : LoopbackContext
            A context manager which will acquire the guard for the
            provided items.

        """
        return LoopbackContext(self, items)

    def __contains__(self, item):
        """ Returns whether or not the given item is currently guarded.

        Parameters
        ----------
        item : object
            The item to check for guarded state.

        Returns
        -------
        result : bool
            True if the item is currently guarded, False otherwise.

        """
        return item in self._locked

    def acquire(self, lock_items):
        """ Acquire the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to release(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to acquire the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] += 1

    def release(self, lock_items):
        """ Release the guard for the given lock items.

        This method is normally called by the LoopbackContext returned
        by calling this instance. User code should not normally call
        this method directly.

        It is safe to call this method multiple times for the same
        item, provided it is paired with an equivalent number of 
        calls to acquire(...). The guard will be released when 
        the acquired count on the item reaches zeros.

        Parameters
        ----------
        lock_items : iterable
            An iterable of objects for which to release the guard. The
            items must be hashable.

        """
        for item in lock_items:
            self._locked[item] -= 1
            if self._locked[item] == 0:
                del self._locked[item]


class ObjectDict(dict):
    """ A dict subclass which exposes its keys as attributes.

    """
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        self[name] = value


def log_exceptions(func):
    """ A decorator which will catch errors raised by a function and
    convert them into log error messages.

    When a decorated function raises an Exception, the return value
    will be None.

    """
    @wraps(func)
    def closure(*args, **kwargs):
        try:
            res = func(*args, **kwargs)
        except Exception:
            # Get the logger for the wrapped function.
            logger = logging.getLogger(func.__module__)
            message = 'Exception occured in `%s`:' % func.__name__
            logger.exception(message)
            res = None
        return res
    return closure

